#!/usr/bin/env python3
import gi.repository
from gi.repository import Gio
import subprocess
import time
import os
import getkeys
import psutil
import atexit
import signal
import sys


"""
Budgie TakeaBreak
Author: Jacob Vlijm
Copyright Â© 2017-2020 Ubuntu Budgie Developers
Website=https://ubuntubudgie.org
This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or any later version. This
program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details. You
should have received a copy of the GNU General Public License along with this
program.  If not, see <http://www.gnu.org/licenses/>.
"""


dcpath = "/com/solus-project/budgie-panel/applets/"
tab_key = "org.ubuntubudgie.plugins.takeabreak"
user = os.environ["USER"]
tab_settings = Gio.Settings.new(tab_key)
# get current settings
auto_unlock = tab_settings.get_boolean("unlockafterbreak")
awaketime = tab_settings.get_int("awaketime") * 60
sleeptime = tab_settings.get_int("sleeptime") * 60
mode = tab_settings.get_string("mode")
notify_msg = tab_settings.get_boolean("showmessage")
notify_time = 15
from_unidle = tab_settings.get_boolean("smartresume")
message = "Break in " + str(notify_time) + " seconds"
tabcountdown_path = os.path.dirname(os.path.abspath(__file__))
messageProcess = None


def getkey():
    return getkeys.by_subval(dcpath, 'name', "'Take a Break'")


def get_idle():
    return int(subprocess.check_output(["xprintidle"]).decode("utf-8"))


def idle_sleep():
    curr_idle1 = get_idle()
    while True:
        time.sleep(3)
        curr_idle2 = get_idle()
        if curr_idle2 <= curr_idle1:
            break
        else:
            curr_idle1 = curr_idle2


def write_nextbreak():
    next_break = time.time() + awaketime
    open("/tmp/nextbreak_" + user, "wt").write(str(next_break))

def get_screens():
    get = subprocess.check_output(["xrandr"]).decode("utf-8").split()
    screens = [get[i - 1] for i in range(len(get)) if get[i] == "connected"]
    return screens

def reset_system_state():
    global messageProcess
    if messageProcess != None:
        messageProcess.kill()
        messageProcess = None
    if auto_unlock:
        subprocess.Popen([
            "gnome-screensaver-command", "-d"
        ])
    screens = get_screens()
    args = ["xrandr"]
    for scr in screens:
        if mode == "rotate":
            args += ["--output", scr, "--rotate", "normal"]
        elif mode == "dim":
            args += ["--output", scr, "--brightness", "1"]
    subprocess.check_call(args)

def exit_handler(signum, frame):
    sys.exit(1)

def setup_exit_handler():
    for sig in (signal.SIGTERM, signal.SIGINT):
        signal.signal(sig, exit_handler)

    atexit.register(reset_system_state)

def remove_exit_handler():
    for sig in (signal.SIGTERM, signal.SIGINT):
        signal.signal(sig, signal.SIG_DFL)

    atexit.unregister(reset_system_state)

def take_a_break():
    global messageProcess
    setup_exit_handler()
    screens = get_screens()
    if mode == "message":
        command = tabcountdown_path + "/message_window"
        messageProcess = subprocess.Popen([command, str(sleeptime)])
    elif mode == "lock":
        subprocess.Popen([
            "gnome-screensaver-command", "-l"
        ])
    else:
        args = ["xrandr"]
        for scr in screens:
            if mode == "rotate":
                args += ["--output", scr, "--rotate", "inverted"]
            elif mode == "dim":
                args += ["--output", scr, "--brightness", "0.1"]
        subprocess.call(args)
    time.sleep(sleeptime)
    reset_system_state()
    remove_exit_handler()
    if from_unidle:
        idle_sleep()


if from_unidle:
    idle_sleep()


def lockscreen_check():
    lockproc = "gnome-screensaver-dialog"
    try:
        return lockproc in (p.name() for p in psutil.process_iter())
    except psutil.NoSuchProcess:
        return False


while True:
    # in case the applet is removed, just quit on next un- sleep
    if not getkey():
        break
    write_nextbreak()
    time.sleep(awaketime - notify_time)
    if not getkey():
        break
    if notify_msg:
        subprocess.Popen([
            "notify-send", "-t", "8000", "-i", "takeabreak-symbolic",
            "Take a break", message,
        ])
    if not getkey():
        break
    time.sleep(notify_time)
    if not getkey():
        break
    else:
        take_a_break()
